<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Document</title>
  <style>
    body {
      margin: 0;
      min-width: 1000px;
      height: 100vh;
      min-height: 600px;
      display: flex;
      justify-content: center;
      align-items: center;
    }
  </style>
</head>

<body>
  <canvas id="canvas"></canvas>
  <script type="text/javascript">
    class CanvasA {
      isDevelopment = true  // 是否开发模式（显示辅助线）

      ctx = undefined
      innerW = 1000         // 界面宽度
      innerH = 600          // 界面高度
      timeToComplete = 3    // 路面和障碍物从最右侧走到最左侧的时间，单位S
      moveSpeed = 6         // 人物移动速度
      commonW = 0           // 单位宽度
      commonH = 0           // 单位高度
      roadSurface = 0       // 路面位置
      roadUnderLines = []   // 路面底部线条数组
      obstacles = []        // 障碍物数组
      peopleX = 0           // 人物坐标x
      peopleY = 0           // 人物坐标y
      /*
       * 操作状态
       */
      operate = {
        jump: false,    // 跳
        squat: false,   // 蹲
        left: false,    // 向左
        right: false,   // 向右
      }
      isMoveUp = false        // 是否在向上移动
      isPause = true          // 是否暂停 默认暂停
      isStart = false         // 是否开始
      // this.traverse = 0    // 惯性 left: -1, right: 1, noMove: 0
      startTime = 0           // 开始时间
      pauseTime = 0           // 暂停时间
      gameDuration = 0        // 游戏时长
      pauseDuration = 0       // 暂停时长

      numberOfRuns = 0

      colorFloor = '#555555'
      colorObstacle = '#191919'
      colorPeople = '#080808'
      colorDevelopBox = '#aaaaaa'

      // colorChecks = ['#181818']

      // colorFloor = 'rgba(0, 0, 0, 0.75)'        // 地面颜色
      // colorObstacle = 'rgba(0, 0, 0, 0.99)'     // 障碍物颜色
      // colorPeople = 'rgba(0, 0, 0, 0.8)'       // 人物颜色
      // colorDevelopBox = 'rgba(0, 0, 0, 0.4)'    // 开发线颜色

      // colorChecks = ['#181818']                 // 碰撞颜色

      /*
       * 腿部移动
       */
      legFunctions = {
        0: this.leg0,
        1: this.leg1,
        2: this.leg2,
        3: this.leg3,
        4: this.leg4,
        5: this.leg5,
        6: this.leg6,
        7: this.leg7,
      }
      legLeft = 1   // 左
      legRight = 4  // 右

      constructor() {
        const NodeCanvas = document.querySelector('#canvas')
        NodeCanvas.width = this.innerW
        NodeCanvas.height = this.innerH
        this.commonW = this.innerH / 10
        this.commonH = this.innerH / 10
        this.roadSurface = this.innerH * 0.8 // road position
        this.ctx = NodeCanvas.getContext('2d')
        this.init()
      }

      init() {
        this.startTime = +new Date()
        this.pauseTime = +new Date()
        this.roadUnderLines = []
        this.obstacles = []
        this.randomUnderLines(Math.round(Math.random() * 5) + 1, 0)
        this.randomObstacle(Math.round(Math.random() * 3) + 1)
        this.draw()
        document.addEventListener('keydown', (e) => this.keydownFun(e))
        document.addEventListener('keyup', (e) => this.keyupFun(e))
      }

      keydownFun(e) {
        const KEY_DOWN = {
          38: () => this.operate.jump = true,
          40: () => this.operate.squat = true,
          37: () => {
            this.operate.left = true
            // !this.operate.jump && (this.traverse = -1)
          },
          39: () => {
            this.operate.right = true
            // !this.operate.jump && (this.traverse = 1)
          },
          32: this.keydownSpace
        }
        KEY_DOWN[e.keyCode] && KEY_DOWN[e.keyCode].call(this)
      }

      keyupFun(e) {
        const KEY_UP = {
          40: () => this.operate.squat = false,
          37: () => this.operate.left = false,
          39: () => this.operate.right = false,
        }
        KEY_UP[e.keyCode] && KEY_UP[e.keyCode].call(this)
      }

      keydownSpace() {
        !this.isStart && (this.isStart = true)
        if (this.isPause) {
          this.isPause = false
          this.pauseDuration = this.pauseTime === 0 ? 0 : this.pauseDuration + (+new Date()) - this.pauseTime
          this.draw()
        } else {
          this.isPause = true
          this.pauseTime = +new Date()
        }
      }

      draw() {
        // pauseStart is after pause and continue the game
        this.ctx.clearRect(0, 0, this.innerW, this.innerH)
        this.ctx.globalCompositeOperation = 'darken'
        this.drawRoad()
        this.drawPeople()
        this.drawObstacle()
        this.drawBgLine()
        if (this.isStart) {
          this.gameDuration = +new Date() - this.startTime - this.pauseDuration
          !this.isPause && requestAnimationFrame(() => this.draw())
        }
      }

      // background line
      drawBgLine() {
        if (this.isDevelopment) {
          for (let i = 1; i <= Math.round(this.innerW / this.commonW); i++) {
            this.ctx.beginPath()
            this.ctx.moveTo(this.commonW * i, 0)
            this.ctx.lineTo(this.commonW * i, this.innerH)
            this.ctx.strokeStyle = this.colorDevelopBox
            this.ctx.lineWidth = 1
            this.ctx.stroke()
          }

          for (let i = 1; i <= 9; i++) {
            this.ctx.beginPath()
            this.ctx.moveTo(0, this.commonH * i)
            this.ctx.lineTo(this.innerW, this.commonH * i)
            this.ctx.strokeStyle = this.colorDevelopBox
            this.ctx.lineWidth = 1
            this.ctx.stroke()
          }
        }
      }

      drawRoad() {
        this.ctx.beginPath()
        this.ctx.moveTo(0, this.roadSurface + 5)
        this.ctx.lineTo(this.innerW, this.roadSurface + 5)
        this.ctx.strokeStyle = this.colorFloor
        this.ctx.lineWidth = 10
        this.ctx.stroke()
        this.roadUnderLines.forEach((item, index) => {
          const movingDistance = this.innerW / (this.timeToComplete * 1000) * (+new Date() - item.startTime - this.pauseDuration + item.nowPauseDuration)
          if (item.positionX + item.length - movingDistance < 0) {
            this.roadUnderLines.splice(index, 1)
          } else {
            this.ctx.beginPath()
            this.ctx.moveTo(item.positionX - movingDistance, item.positionY)
            this.ctx.lineTo(item.positionX + item.length - movingDistance, item.positionY)
            this.ctx.strokeStyle = this.colorFloor
            this.ctx.lineWidth = item.width
            this.ctx.stroke()
          }
        })
        this.roadUnderLines.length < 3 && this.randomUnderLines(Math.round(Math.random() * 2) + 1, this.innerW)
      }

      drawObstacle() {
        this.ctx.save()
        this.ctx.translate(0, this.roadSurface)
        this.obstacles.forEach((item, index) => {
          const movingDistance = this.innerW / (this.timeToComplete * 1000) * (+new Date() - item.startTime - this.pauseDuration + item.nowPauseDuration)
          if (item.positionX + item.width - movingDistance < 0) {
            this.obstacles.splice(index, 1)
          } else {
            this.ctx.beginPath()
            this.ctx.rect(
              item.positionX - movingDistance,
              item.positionY,
              item.width,
              -item.height,
            )
            this.ctx.fillStyle = this.colorObstacle
            this.ctx.fill()
          }
        })
        this.ctx.restore()
        this.obstacles.filter(i => {
          const movingDistance = this.innerW / (this.timeToComplete * 1000) * (+new Date() - i.startTime - this.pauseDuration + i.nowPauseDuration)
          return i.positionX - movingDistance + i.width > this.innerW
        }).length < 2 && this.randomObstacle(1)
      }

      drawPeople() {
        // 蹲时身高减半
        const peopleH = this.operate.squat ? -this.commonH : 2 * -this.commonH
        // // 开启惯性 跳跃时不能运动
        // const perX = this.peopleX +
        //   (this.operate.jump
        //     ? (this.traverse < 0 ? (-this.moveSpeed) : this.traverse > 0 ? this.moveSpeed : 0)
        //     : (this.operate.left ? (-this.moveSpeed) : this.operate.right ? this.moveSpeed : 0))

        // 跳跃时可以运动
        const perX = this.peopleX + (this.operate.left ? (-this.moveSpeed) : this.operate.right ? this.moveSpeed : 0)
        let x = this.commonW + perX
        // 人物到达左右边界
        if (x > 0 && x < this.innerW - this.commonW) {
          this.peopleX = perX
        } else if (x <= 0) {
          x = 0
          this.peopleX = -this.commonW
        } else if (x >= this.innerW - this.commonW) {
          x = this.innerW - this.commonW
          this.peopleX = this.innerW - 2 * this.commonW
        }

        // 跳跃
        const y = 3 * this.commonH
        const moveY = (y - this.peopleY) / 10 + 1
        if (this.operate.jump) {
          this.peopleY === 0 && (this.isMoveUp = true)
          if (this.isMoveUp) {
            this.peopleY < y ? this.peopleY += moveY : this.isMoveUp = false
          } else {
            const lastY = this.peopleY - moveY
            this.peopleY = lastY > 0 ? lastY : 0
            this.operate.jump = !!(lastY > 0)
            // !(lastY > 0) && (this.traverse = 0)
          }
        }

        this.ctx.save()
        this.ctx.translate(0, this.roadSurface)
        // 开发辅助线
        if (this.isDevelopment) {
          this.ctx.beginPath()
          this.ctx.rect(
            x,
            0 - this.peopleY,
            this.commonW,
            peopleH
          )
          this.ctx.lineWidth = 2
          this.ctx.strokeStyle = this.colorDevelopBox
          this.ctx.stroke()

          // 辅助坐标线
          this.ctx.beginPath()
          this.ctx.moveTo(x, -this.peopleY)
          this.ctx.lineTo(x, -this.peopleY + 20)
          this.ctx.lineTo(x - 5, -this.peopleY + 20)
          this.ctx.lineTo(x, -this.peopleY + 25)
          this.ctx.lineTo(x + 5, -this.peopleY + 20)
          this.ctx.lineTo(x, -this.peopleY + 20)
          this.ctx.stroke()

          this.ctx.beginPath()
          this.ctx.moveTo(x, -this.peopleY)
          this.ctx.lineTo(x + this.commonW + 20, -this.peopleY)
          this.ctx.lineTo(x + this.commonW + 20, -this.peopleY + 5)
          this.ctx.lineTo(x + this.commonW + 25, -this.peopleY)
          this.ctx.lineTo(x + this.commonW + 20, -this.peopleY - 5)
          this.ctx.lineTo(x + this.commonW + 20, -this.peopleY)
          this.ctx.stroke()
        }

        // head
        this.ctx.beginPath()
        this.ctx.arc(
          x + this.commonW / 4 * 3 - this.commonW / 32 * 3,
          0 - this.peopleY + peopleH - (- this.commonH / 4),
          this.commonW / 6,
          0,
          2 * Math.PI
        )
        this.ctx.fillStyle = this.colorPeople
        this.ctx.fill()
        this.ctx.lineWidth = 5
        this.ctx.strokeStyle = this.colorPeople
        this.ctx.lineCap = 'round'
        this.ctx.lineJoin = 'round'
        const bodyStartX = x + this.commonW / 4 * 2
        const bodyStartY = 0 - this.peopleY + peopleH - (- this.commonH / 2) - this.commonH / 8
        // neck
        this.ctx.beginPath()
        this.ctx.moveTo(bodyStartX, bodyStartY)
        this.ctx.lineTo(
          bodyStartX + this.commonW / 8,
          bodyStartY - this.commonH / 8
        )
        this.ctx.stroke()

        this.operate.squat
          ? this.bodyIsSquat(x, y, bodyStartX, bodyStartY, peopleH)
          : this.bodyIsNotSquat(x, y, bodyStartX, bodyStartY, peopleH)
        this.ctx.restore()
        // do impact checking
        this.impactChecking({
          x,
          y: 0 - this.peopleY,
          w: this.commonW,
          h: peopleH
        })
      }

      // 人物蹲
      bodyIsSquat(x, y, bodyStartX, bodyStartY, peopleH) {
        // body
        this.ctx.beginPath()
        this.ctx.moveTo(bodyStartX, bodyStartY)
        this.ctx.lineTo(
          x + this.commonW / 4,
          0 - this.peopleY + peopleH - (- this.commonH / 2),
        )
        this.ctx.stroke()

        const legStartX = x + this.commonW / 4
        const legStartY = 0 - this.peopleY + peopleH - (- this.commonH / 2)
        // legs
        this.ctx.beginPath()
        this.ctx.moveTo(legStartX, legStartY)
        this.ctx.lineTo(
          legStartX + this.commonW / 5 * 2,
          legStartY + this.commonH / 4
        )
        this.ctx.lineTo(
          legStartX - this.commonW / 16,
          legStartY + this.commonH / 2 - this.commonH / 8
        )
        this.ctx.lineTo(
          legStartX,
          legStartY + this.commonH / 2
        )
        this.ctx.stroke()

        this.ctx.beginPath()
        this.ctx.moveTo(legStartX, legStartY)
        this.ctx.lineTo(
          legStartX + this.commonW / 5 * 2,
          legStartY + this.commonH / 4
        )
        this.ctx.lineTo(
          legStartX + this.commonW / 16,
          legStartY + this.commonH / 2 - this.commonH / 8
        )
        this.ctx.lineTo(
          legStartX + this.commonW / 16 * 2,
          legStartY + this.commonH / 2
        )
        this.ctx.stroke()

        // arms
        this.ctx.beginPath()
        this.ctx.moveTo(bodyStartX, bodyStartY)
        this.ctx.lineTo(
          legStartX,
          bodyStartY - this.commonH / 4
        )
        this.ctx.lineTo(legStartX, legStartY)
        this.ctx.stroke()
      }

      // 人物正常身形
      bodyIsNotSquat(x, y, bodyStartX, bodyStartY, peopleH) {
        // body
        this.ctx.beginPath()
        this.ctx.moveTo(
          bodyStartX,
          bodyStartY,
        )
        this.ctx.lineTo(
          x + this.commonW / 2,
          0 - this.peopleY + peopleH - (- this.commonH),
        )
        this.ctx.stroke()

        const legStartX = x + this.commonW / 2
        const legStartY = 0 - this.peopleY + peopleH - (- this.commonH)

        // legs
        if (this.operate.jump) {
          this.leg0(legStartX, legStartY)
          this.leg3(legStartX, legStartY)
        } else {
          this.legFunctions[this.legLeft].call(this, legStartX, legStartY)
          this.legFunctions[this.legRight].call(this, legStartX, legStartY)
          this.legLeft = Math.floor((this.gameDuration / 100) % 8)
          this.legRight = Math.floor(((this.gameDuration / 100) + 4) % 8)
        }

        // arms
        this.ctx.beginPath()
        this.ctx.moveTo(bodyStartX, bodyStartY)
        this.ctx.lineTo(
          x + this.commonW / 4 * 1,
          0 - this.peopleY + peopleH - (- this.commonH) / 4 * 3,
        )
        this.ctx.lineTo(
          x + this.commonW / 2,
          0 - this.peopleY + peopleH - (- this.commonH),
        )
        this.ctx.stroke()
      }

      impactChecking(people) {
        const { x, y, w, h } = people
        // console.log(x, y, w, h)
        // console.log(this.ctx.getImageData(x, y, w, -h).data.join(''))
        if (this.numberOfRuns % 16 === 0) {
          // console.log(this.ctx.getImageData(x, y, w, h).data.join(''))
        }
        // console.log(people)
        // for (let i = x; i < x + w; i = i + 10) {
        //   for (let j = y; j > y + h; j = j - 10) {
        //     // if (this.ctx.getImageData(i, j, 1, 1).data[3] !== 0.99 && this.ctx.getImageData(i, j, 1, 1).data[3] !== 0) {
        //     //   console.log(this.ctx.getImageData(i, j, 1, 1).data)
        //     //   return
        //     // }
        //     console.log(this.ctx.getImageData(i, j, 10, 10).data)
        //   }
        // }
        // console.log(this.ctx.getImageData(people.x, people.y, 1, 1).data[3])
        for (let i of this.obstacles) {
          const movingDistance = this.innerW / (this.timeToComplete * 1000) * (+new Date() - i.startTime - this.pauseDuration + i.nowPauseDuration)
          const obstacle = {
            iX: i.positionX - movingDistance,
            iY: i.positionY,
            iW: i.width,
            iH: -i.height,
          }
          if (this.impactCheckingVerity(people, obstacle)) {
            console.log('is check')
          }
        }
      }

      impactCheckingVerity(people, obstacle) {
        const { x, y, w, h } = people
        const { iX, iY, iW, iH } = obstacle
        // because y and h is negative number
        // so compare use negate
        return x + w >= iX && x <= iX + iW && y + h <= iY && y >= iY + iH
      }

      randomUnderLines(randomNumber, addPositionX = 0) {
        for (let i = 0; i <= randomNumber; i++) {
          const w = Math.round(Math.random() * 5) + 1
          this.roadUnderLines.push({
            length: this.commonW * (Math.round(Math.random() * 6) + 1) / 2,
            width: w,
            positionX: Math.round(Math.random() * this.innerW) - w + addPositionX,
            positionY: this.roadSurface + Math.random() * (this.innerH - this.roadSurface),
            nowPauseDuration: this.pauseDuration,
            startTime: +new Date(),
          })
        }
      }

      randomObstacle(randomNumber) {
        for (let i = 0; i <= randomNumber; i++) {
          const isFly = !!(Math.random() > 0.5)
          const h = Math.round(0.7 * this.commonH * (Math.round(Math.random() * 2) + 1))
          const w = Math.round(0.2 * this.commonW * (Math.round(Math.random() * 5) + 1))
          const last = this.obstacles[this.obstacles.length - 1]
          // is not first one
          const movingDistance = last
            ? this.innerW / (this.timeToComplete * 1000) * (+new Date() - last.startTime - this.pauseDuration + last.nowPauseDuration)
            : 0
          const lastPositionX = last ? last.positionX - movingDistance + last.width : this.innerW
          const positionX = Math.round(Math.random() * this.innerW) / 2 + lastPositionX + 3 * this.commonW
          this.obstacles.push({
            height: h,
            width: w,
            positionX,
            positionY: isFly ? -(Math.round(Math.random()) + 0.5) * this.commonH : 0,
            startTime: +new Date(), // 创建时间
            nowPauseDuration: this.pauseDuration, // 当前暂停时间
            isFly, // 是否在空中
            isPassed: false, // 是否通过
            centerX: w + positionX / 2, // 中心点X坐标
          })
        }
      }

      leg0(x, y) {
        const { commonH, commonW } = this
        this.ctx.beginPath()
        this.ctx.moveTo(x, y)
        this.ctx.lineTo(x + commonW / 4, y - (-commonH / 3))
        this.ctx.lineTo(x + (commonW / 8) * 3, y - (-commonH))
        this.ctx.lineTo(x + (commonW / 8) * 3 + commonW / 8, y - (-commonH))
        this.ctx.stroke()
      }

      leg1(x, y) {
        const { commonH, commonW } = this
        this.ctx.beginPath()
        this.ctx.moveTo(x, y)
        this.ctx.lineTo(x + commonW / 8, y - (-commonH / 5) * 2)
        this.ctx.lineTo(x + (commonW / 16) * 3, y - (-commonH))
        this.ctx.lineTo(x + (commonW / 16) * 3 + commonW / 8, y - (-commonH))
        this.ctx.stroke()
      }

      leg2(x, y) {
        const { commonH, commonW } = this
        this.ctx.beginPath()
        this.ctx.moveTo(x, y)
        this.ctx.lineTo(x + commonW / 16, y - (-commonH / 2))
        this.ctx.lineTo(x - (commonW / 8), y - (-commonH))
        this.ctx.lineTo(x, y - (-commonH))
        this.ctx.stroke()
      }

      leg3(x, y) {
        const { commonH, commonW } = this
        this.ctx.beginPath()
        this.ctx.moveTo(x, y)
        this.ctx.lineTo(x - commonW / 16, y - (-commonH / 5) * 2)
        this.ctx.lineTo(x - (commonW / 8) * 3, y - (-commonH / 8) * 7)
        this.ctx.lineTo(x - (commonW / 8) * 3, y - (-commonH))
        this.ctx.stroke()
      }

      leg4(x, y) {
        const { commonH, commonW } = this
        this.ctx.beginPath()
        this.ctx.moveTo(x, y)
        this.ctx.lineTo(x - commonW / 8, y - (-commonH / 3) * 1)
        this.ctx.lineTo(x - (commonW / 8) * 4, y - (-commonH / 4) * 1)
        this.ctx.lineTo(x - (commonW / 8) * 4, y - (-commonH / 8) * 3)
        this.ctx.stroke()
      }

      leg5(x, y) {
        const { commonH, commonW } = this
        this.ctx.beginPath()
        this.ctx.moveTo(x, y)
        this.ctx.lineTo(x + commonW / 4, y - (-commonH / 4) * 1)
        this.ctx.lineTo(x + commonW / 4 - (commonW / 2), y - (-commonH / 4) * 1)
        this.ctx.lineTo(x + commonW / 4 - (commonW / 3) * 2, y - (-commonH / 8) * 3)
        this.ctx.stroke()
      }

      leg6(x, y) {
        const { commonH, commonW } = this
        this.ctx.beginPath()
        this.ctx.moveTo(x, y)
        this.ctx.lineTo(x + (commonW / 16) * 6, y - (-commonH / 8) * 1)
        this.ctx.lineTo(x, y - (-commonH / 2) * 1)
        this.ctx.lineTo(x + commonW / 8, y - (-commonH / 8) * 5)
        this.ctx.stroke()
      }

      leg7(x, y) {
        const { commonH, commonW } = this
        this.ctx.beginPath()
        this.ctx.moveTo(x, y)
        this.ctx.lineTo(x + (commonW / 8) * 3, y - (-commonH / 3))
        this.ctx.lineTo(x + (commonW / 8) * 3, y - (-commonH))
        this.ctx.lineTo(x + (commonW / 8) * 3 + commonW / 8, y - (-commonH))
        this.ctx.stroke()
      }
    }
    new CanvasA()
  </script>
</body>

</html>