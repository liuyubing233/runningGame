<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Document</title>
  <style>
    body {
      margin: 0;
      min-width: 1000px;
      height: 100vh;
      min-height: 600px;
      display: flex;
      justify-content: center;
      align-items: center;
    }
  </style>
</head>

<body>
  <canvas id="canvas"></canvas>
  <script type="text/javascript">
    class CanvasA {
      isDevelopment = true  // 是否开发模式（显示辅助线）
      canPause = true       // 是否可以暂停

      ctx = undefined
      innerW = 1000         // 界面宽度
      innerH = 600          // 界面高度
      timeToComplete = 3    // 路面和障碍物从最右侧走到最左侧的时间，单位S
      moveSpeed = 6         // 人物移动速度
      commonW = 0           // 单位宽度
      commonH = 0           // 单位高度
      roadSurface = 0       // 路面位置
      roadUnderLines = []   // 路面底部线条数组
      obstacles = []        // 障碍物数组
      peopleX = 0           // 人物坐标x
      peopleY = 0           // 人物坐标y
      /*
       * 操作状态
       */
      operate = {
        jump: false,    // 跳
        squat: false,   // 蹲
        left: false,    // 向左
        right: false,   // 向右
      }
      isMoveUp = false        // 是否在向上移动
      isPause = true          // 是否暂停 默认暂停
      isStart = false         // 是否开始
      // this.traverse = 0    // 惯性 left: -1, right: 1, noMove: 0
      startTime = 0           // 开始时间
      pauseTime = 0           // 暂停时间
      gameDuration = 0        // 游戏时长
      pauseDuration = 0       // 暂停时长

      numberOfRuns = 0

      colorFloor = '#111f2c'        // 地面颜色
      colorObstacle = '#111f2c'     // 障碍物颜色
      colorPeople = '#111f2c'       // 人物颜色
      colorDevelopBox = '#aaaaaa'   // 开发线颜色
      colorBackground = '#ffffff'   // 背景颜色

      legLeft = 1   // 左
      legRight = 4  // 右

      constructor() {
        const NodeCanvas = document.querySelector('#canvas')
        NodeCanvas.width = this.innerW
        NodeCanvas.height = this.innerH
        this.commonW = this.innerH / 10
        this.commonH = this.innerH / 10
        this.roadSurface = this.innerH * 0.8 // road position
        this.ctx = NodeCanvas.getContext('2d')
        this.init()
      }

      init() {
        this.startTime = +new Date()
        this.pauseTime = +new Date()
        this.roadUnderLines = []
        this.obstacles = []
        this.randomUnderLines(Math.round(Math.random() * 5) + 1, 0)
        this.randomObstacle(Math.round(Math.random() * 3) + 1)
        this.draw()
        document.addEventListener('keydown', (e) => this.keydownFun(e))
        document.addEventListener('keyup', (e) => this.keyupFun(e))
      }

      keydownFun(e) {
        const KEY_DOWN = {
          38: () => this.operate.jump = true,
          40: () => this.operate.squat = true,
          37: () => {
            this.operate.left = true
            // !this.operate.jump && (this.traverse = -1)
          },
          39: () => {
            this.operate.right = true
            // !this.operate.jump && (this.traverse = 1)
          },
          32: this.keydownSpace
        }
        KEY_DOWN[e.keyCode] && KEY_DOWN[e.keyCode].call(this)
      }

      keyupFun(e) {
        const KEY_UP = {
          40: () => this.operate.squat = false,
          37: () => this.operate.left = false,
          39: () => this.operate.right = false,
        }
        KEY_UP[e.keyCode] && KEY_UP[e.keyCode].call(this)
      }

      keydownSpace() {
        !this.isStart && (this.isStart = true)
        if (this.canPause) {
          if (this.isPause) {
            this.isPause = false
            this.pauseDuration = this.pauseTime === 0 ? 0 : this.pauseDuration + (+new Date()) - this.pauseTime
          } else {
            this.isPause = true
            this.pauseTime = +new Date()
          }
        }
        this.draw()
      }

      draw() {
        // pauseStart is after pause and continue the game
        this.ctx.clearRect(0, 0, this.innerW, this.innerH)
        // this.ctx.globalCompositeOperation = 'darken'
        this.drawBgLine()
        this.drawRoad()
        this.drawObstacle()
        this.drawPeople()
        if (this.isStart) {
          this.gameDuration = +new Date() - this.startTime - this.pauseDuration
          !this.isPause && requestAnimationFrame(() => this.draw())
        }
      }

      // background line
      drawBgLine() {
        if (this.isDevelopment) {
          this.ctx.strokeStyle = this.colorDevelopBox
          this.ctx.lineWidth = 1
          for (let i = 1; i <= Math.round(this.innerW / this.commonW); i++) {
            this.funLines([this.commonW * i, 0], [this.commonW * i, this.innerH])
          }
          for (let i = 1; i <= 9; i++) {
            this.funLines([0, this.commonH * i], [this.innerW, this.commonH * i])
          }
        }
      }

      drawRoad() {
        this.ctx.strokeStyle = this.colorFloor
        this.ctx.lineWidth = 10
        this.funLines([0, this.roadSurface + 5], [this.innerW, this.roadSurface + 5])
        this.roadUnderLines.forEach((item, index) => {
          const movingDistance = this.getMovingDistance(item)
          if (item.positionX + item.length - movingDistance < 0) {
            this.roadUnderLines.splice(index, 1)
          } else {
            this.ctx.lineWidth = item.width
            this.funLines(
              [item.positionX - movingDistance, item.positionY],
              [item.positionX + item.length - movingDistance, item.positionY],
            )
          }
        })
        this.roadUnderLines.length < 3 && this.randomUnderLines(Math.round(Math.random() * 2) + 1, this.innerW)
      }

      drawObstacle() {
        this.ctx.save()
        this.ctx.translate(0, this.roadSurface)
        this.obstacles.forEach((item, index) => {
          const movingDistance = this.getMovingDistance(item)
          item.positionX + item.width - movingDistance < 0
            ? this.obstacles.splice(index, 1)
            : this.obstacleItemDraw(item, movingDistance)
        })
        this.ctx.restore()
        this.obstacles.filter(i => i.positionX - this.getMovingDistance(i) + i.width > this.innerW).length < 2 && this.randomObstacle(1)
      }

      obstacleItemDraw(item, movingDistance) {
        const { width, height, positionX, positionY, type } = item
        const poX = positionX - movingDistance
        if (this.isDevelopment) {
          this.ctx.lineWidth = 2
          this.ctx.strokeStyle = this.colorDevelopBox
          this.funStrokeRect(poX, positionY, width, -height)
        }

        // 轮廓
        this.ctx.strokeStyle = this.colorObstacle
        this.ctx.lineWidth = 2
        // 嘴
        this.funLines(
          [poX + width / 4, positionY],
          [poX + width / 4, positionY - height / 3],
          [poX + width / 4 * 3, positionY - height / 3],
          [poX + width / 4 * 3, positionY],
        )
        // 嘴上部左右方块
        this.funStrokeRect(poX, positionY - height / 2, width / 5, height / 8)
        this.funStrokeRect(poX + width / 5 * 4, positionY - height / 2, width / 5, height / 8)
        // this.ctx.lineWidth = 4
        this.ctx.lineJoin = 'bevel'
        const typeFun = {
          0: this.obstacleType0,
          1: this.obstacleType1,
          2: this.obstacleType2,
        }
        typeFun[type] && typeFun[type].call(this, item, poX)
      }

      obstacleType0(item, poX) {
        const { width, height, positionX, positionY, type, left, right } = item
        const eyesY = positionY - height + width

        // left arm
        this.ctx.beginPath()
        this.ctx.moveTo(poX, positionY - height / 2)
        this.ctx.arcTo(
          poX - width * 2,
          positionY - height / 2,
          poX - width * 2.5,
          left ? positionY - height / 3 : positionY - height / 3 * 2,
          width
        )
        this.ctx.lineTo(
          poX - width * 2.5,
          left ? positionY - height / 3 : positionY - height / 3 * 2,
        )
        this.ctx.stroke()

        // right arm
        this.ctx.beginPath()
        this.ctx.moveTo(poX + width, positionY - height / 2)
        this.ctx.arcTo(
          poX + width + width * 2,
          positionY - height / 2,
          poX + width + width * 2.5,
          right ? positionY - height / 3 : positionY - height / 3 * 2,
          width
        )
        this.ctx.lineTo(
          poX + width + width * 2.5,
          right ? positionY - height / 3 : positionY - height / 3 * 2,
        )
        this.ctx.stroke()

        // eye
        this.funStrokeRect(poX, eyesY, width, height - width)
        this.ctx.fillStyle = this.colorBackground
        this.funFillCircle(poX + width / 2, eyesY, width)
        this.funStrokeCircle(poX + width / 2, eyesY, width)
        this.ctx.fillStyle = this.colorObstacle
        this.funFillCircle(poX + width / 2, eyesY, width / 2)
      }

      obstacleType1(item, poX) {
        const { width, height, positionX, positionY, type } = item
        const eyesY = positionY - height + width / 2 + height / 9
        this.funStrokeRect(poX, positionY, width, -height)
        // 单眼
        this.funStrokeCircle(poX + width / 2, eyesY, (width - 8) / 2)
        this.funFillCircle(poX + width / 2, eyesY, (width - 8) / 5)
        // 眉
        this.ctx.beginPath()
        this.ctx.moveTo(
          poX + width / 4,
          positionY - height + height / 10
        )
        this.ctx.arcTo(
          poX + width / 2,
          positionY - height,
          poX + width / 4 * 3,
          positionY - height + height / 10,
          (width - 8) / 5,
        )
        this.ctx.lineTo(
          poX + width / 4 * 3,
          positionY - height + height / 10,
        )
        this.ctx.stroke()
      }

      obstacleType2(item, poX) {
        const { width, height, positionX, positionY, type } = item
        const eyesY = positionY - height + width / 4
        // body
        this.funLines(
          [poX, eyesY],
          [poX, positionY],
          [poX + width, positionY],
          [poX + width, eyesY]
        )
        // 双眼
        this.ctx.fillStyle = this.colorBackground
        this.funFillCircle(poX + width / 4, eyesY, width / 4)
        this.funFillCircle(poX + width / 4 * 3, eyesY, width / 4)
        this.funStrokeCircle(poX + width / 4, eyesY, width / 4)
        this.funStrokeCircle(poX + width / 4 * 3, eyesY, width / 4)
        this.ctx.fillStyle = this.colorObstacle
        this.funFillCircle(poX + width / 4, eyesY, width / 6)
        this.funFillCircle(poX + width / 4 * 3, eyesY, width / 6)
      }

      drawPeople() {
        // 蹲时身高减半
        const peopleH = this.operate.squat ? -this.commonH : 2 * -this.commonH
        // // 开启惯性 跳跃时不能运动
        // const perX = this.peopleX +
        //   (this.operate.jump
        //     ? (this.traverse < 0 ? (-this.moveSpeed) : this.traverse > 0 ? this.moveSpeed : 0)
        //     : (this.operate.left ? (-this.moveSpeed) : this.operate.right ? this.moveSpeed : 0))

        // 跳跃时可以运动
        const perX = this.peopleX + (this.operate.left ? (-this.moveSpeed) : this.operate.right ? this.moveSpeed : 0)
        let x = this.commonW + perX
        // 人物到达左右边界
        if (x > 0 && x < this.innerW - this.commonW) {
          this.peopleX = perX
        } else if (x <= 0) {
          x = 0
          this.peopleX = -this.commonW
        } else if (x >= this.innerW - this.commonW) {
          x = this.innerW - this.commonW
          this.peopleX = this.innerW - 2 * this.commonW
        }

        // 跳跃
        const y = 3 * this.commonH
        const moveY = (y - this.peopleY) / 10 + 1
        if (this.operate.jump) {
          this.peopleY === 0 && (this.isMoveUp = true)
          if (this.isMoveUp) {
            this.peopleY < y ? this.peopleY += moveY : this.isMoveUp = false
          } else {
            const lastY = this.peopleY - moveY
            this.peopleY = lastY > 0 ? lastY : 0
            this.operate.jump = !!(lastY > 0)
            // !(lastY > 0) && (this.traverse = 0)
          }
        }

        this.ctx.save()
        this.ctx.translate(0, this.roadSurface)
        // 开发辅助线
        if (this.isDevelopment) {
          this.ctx.lineWidth = 2
          this.ctx.strokeStyle = this.colorDevelopBox
          this.funStrokeRect(x, 0 - this.peopleY, this.commonW, peopleH)
          // 辅助坐标线
          this.funLines(
            [x, -this.peopleY],
            [x, -this.peopleY + 20],
            [x - 5, -this.peopleY + 20],
            [x, -this.peopleY + 25],
            [x + 5, -this.peopleY + 20],
            [x, -this.peopleY + 20],
          )
          this.funLines(
            [x, -this.peopleY],
            [x + this.commonW + 20, -this.peopleY],
            [x + this.commonW + 20, -this.peopleY + 5],
            [x + this.commonW + 25, -this.peopleY],
            [x + this.commonW + 20, -this.peopleY - 5],
            [x + this.commonW + 20, -this.peopleY],
          )
        }
        // head
        this.ctx.fillStyle = this.colorPeople
        this.funFillCircle(
          x + this.commonW / 4 * 3 - this.commonW / 32 * 3,
          0 - this.peopleY + peopleH - (- this.commonH / 4),
          this.commonW / 6
        )
        this.ctx.lineWidth = 5
        this.ctx.strokeStyle = this.colorPeople
        this.ctx.lineCap = 'round'
        this.ctx.lineJoin = 'round'
        const bodyStartX = x + this.commonW / 4 * 2
        const bodyStartY = 0 - this.peopleY + peopleH - (- this.commonH / 2) - this.commonH / 8
        // neck
        this.funLines(
          [bodyStartX, bodyStartY],
          [bodyStartX + this.commonW / 8, bodyStartY - this.commonH / 8]
        )
        // legs
        this.operate.squat
          ? this.bodyIsSquat(x, y, bodyStartX, bodyStartY, peopleH)
          : this.bodyIsNotSquat(x, y, bodyStartX, bodyStartY, peopleH)
        this.ctx.restore()
        // do impact checking
        this.impactChecking({
          x,
          y: 0 - this.peopleY,
          w: this.commonW,
          h: peopleH
        })
      }

      // 人物蹲
      bodyIsSquat(x, y, bodyStartX, bodyStartY, peopleH) {
        // body
        this.funLines(
          [bodyStartX, bodyStartY],
          [x + this.commonW / 4, 0 - this.peopleY + peopleH - (- this.commonH / 2),]
        )
        const legStartX = x + this.commonW / 4
        const legStartY = 0 - this.peopleY + peopleH - (- this.commonH / 2)
        // legs
        this.funLines(
          [legStartX, legStartY],
          [legStartX + this.commonW / 5 * 2, legStartY + this.commonH / 4],
          [legStartX - this.commonW / 16, legStartY + this.commonH / 2 - this.commonH / 8],
          [legStartX, legStartY + this.commonH / 2],
        )
        this.funLines(
          [legStartX, legStartY],
          [legStartX + this.commonW / 5 * 2, legStartY + this.commonH / 4],
          [legStartX + this.commonW / 16, legStartY + this.commonH / 2 - this.commonH / 8],
          [legStartX + this.commonW / 16 * 2, legStartY + this.commonH / 2],
        )
        // arms
        this.funLines(
          [bodyStartX, bodyStartY],
          [legStartX, bodyStartY - this.commonH / 4],
          [legStartX, legStartY],
        )
      }

      // 人物正常身形
      bodyIsNotSquat(x, y, bodyStartX, bodyStartY, peopleH) {
        // body
        this.funLines(
          [bodyStartX, bodyStartY],
          [x + this.commonW / 2, 0 - this.peopleY + peopleH - (- this.commonH)]
        )

        const legStartX = x + this.commonW / 2
        const legStartY = 0 - this.peopleY + peopleH - (- this.commonH)

        // legs
        if (this.operate.jump) {
          this.leg0(legStartX, legStartY)
          this.leg3(legStartX, legStartY)
        } else {
          const legFunctions = {
            0: this.leg0,
            1: this.leg1,
            2: this.leg2,
            3: this.leg3,
            4: this.leg4,
            5: this.leg5,
            6: this.leg6,
            7: this.leg7,
          }

          legFunctions[this.legLeft].call(this, legStartX, legStartY)
          legFunctions[this.legRight].call(this, legStartX, legStartY)
          this.legLeft = Math.floor((this.gameDuration / 100) % 8)
          this.legRight = Math.floor(((this.gameDuration / 100) + 4) % 8)
        }

        // arms
        this.funLines(
          [bodyStartX, bodyStartY],
          [x + this.commonW / 4 * 1, 0 - this.peopleY + peopleH - (- this.commonH) / 4 * 3],
          [x + this.commonW / 2, 0 - this.peopleY + peopleH - (- this.commonH)],
        )
      }

      // 碰撞检测
      impactChecking(people) {
        const { x, y, w, h } = people
        for (let i of this.obstacles) {
          const movingDistance = this.getMovingDistance(i)
          const obstacle = {
            iX: i.positionX - movingDistance,
            iY: i.positionY,
            iW: i.width,
            iH: -i.height,
          }
          if (this.impactCheckingVerity(people, obstacle)) {
            console.log('is check')
          }
        }
      }

      impactCheckingVerity(people, obstacle) {
        const { x, y, w, h } = people
        const { iX, iY, iW, iH } = obstacle
        // because y and h is negative number
        // so compare use negate
        return x + w >= iX && x <= iX + iW && y + h <= iY && y >= iY + iH
      }

      randomUnderLines(randomNumber, addPositionX = 0) {
        for (let i = 0; i <= randomNumber; i++) {
          const w = Math.round(Math.random() * 5) + 1
          this.roadUnderLines.push({
            length: this.commonW * (Math.round(Math.random() * 6) + 1) / 2,
            width: w,
            positionX: Math.round(Math.random() * this.innerW) - w + addPositionX,
            positionY: this.roadSurface + Math.random() * (this.innerH - this.roadSurface),
            nowPauseDuration: this.pauseDuration,
            startTime: +new Date(),
          })
        }
      }

      randomObstacle(randomNumber) {
        for (let i = 0; i <= randomNumber; i++) {
          const isFly = !!(Math.random() > 0.5)
          const height = Math.round(0.7 * this.commonH * (Math.round(Math.random() * 2) + 1))
          const width = Math.round(0.2 * this.commonW * (Math.round(Math.random() * 5) + 1))
          const last = this.obstacles[this.obstacles.length - 1]
          // is not first one
          const movingDistance = last ? this.getMovingDistance(last) : 0
          const lastPositionX = last ? last.positionX - movingDistance + last.width : this.innerW
          const positionX = Math.round(Math.random() * this.innerW) / 2 + lastPositionX + 3 * this.commonW
          let type = 0
          if (width <= this.commonW / 4) {
            type = 0
          } else if (width * 2 <= height) {
            type = 1
          } else {
            type = 2
          }
          this.obstacles.push({
            height,
            width,
            isFly, // 是否在空中
            positionX,
            positionY: isFly ? -(Math.round(Math.random()) + 0.5) * this.commonH : 0,
            startTime: +new Date(), // 创建时间
            nowPauseDuration: this.pauseDuration, // 当前暂停时间
            isPassed: false, // 是否通过
            centerX: width + positionX / 2, // 中心点X坐标
            type, // 类型
            left: !!(Math.random() > 0.5),
            right: !!(Math.random() > 0.5),
          })
        }
      }

      // 获取移动距离
      getMovingDistance(item) {
        return this.innerW / (this.timeToComplete * 1000) * (+new Date() - item.startTime - this.pauseDuration + item.nowPauseDuration)
      }

      funLines(...args) {
        if (args.length) {
          this.ctx.beginPath()
          args.forEach((item, index) => {
            index === 0
              ? this.ctx.moveTo(item[0], item[1])
              : this.ctx.lineTo(item[0], item[1])
          })
          this.ctx.stroke()
        }
      }

      funStrokeCircle(x, y, r, start = 0, end = 2 * Math.PI) {
        this.ctx.beginPath()
        this.ctx.arc(x, y, r, start, end)
        this.ctx.stroke()
      }

      funFillCircle(x, y, r, start = 0, end = 2 * Math.PI) {
        this.ctx.beginPath()
        this.ctx.arc(x, y, r, start, end)
        this.ctx.fill()
      }

      funStrokeRect(x, y, w, h) {
        this.ctx.beginPath()
        this.ctx.rect(x, y, w, h)
        this.ctx.stroke()
      }

      funFillRect(x, y, w, h) {
        this.ctx.beginPath()
        this.ctx.rect(x, y, w, h)
        this.ctx.fill()
      }

      leg0(x, y) {
        const { commonH, commonW } = this
        this.funLines(
          [x, y],
          [x + commonW / 4, y - (-commonH / 3)],
          [x + (commonW / 8) * 3, y - (-commonH)],
          [x + (commonW / 8) * 3 + commonW / 8, y - (-commonH)]
        )
      }

      leg1(x, y) {
        const { commonH, commonW } = this
        this.funLines(
          [x, y],
          [x + commonW / 8, y - (-commonH / 5) * 2],
          [x + (commonW / 16) * 3, y - (-commonH)],
          [x + (commonW / 16) * 3 + commonW / 8, y - (-commonH)],
        )
      }

      leg2(x, y) {
        const { commonH, commonW } = this
        this.funLines(
          [x, y],
          [x + commonW / 16, y - (-commonH / 2)],
          [x - (commonW / 8), y - (-commonH)],
          [x, y - (-commonH)],
        )
      }

      leg3(x, y) {
        const { commonH, commonW } = this
        this.funLines(
          [x, y],
          [x - commonW / 16, y - (-commonH / 5) * 2],
          [x - (commonW / 8) * 3, y - (-commonH / 8) * 7],
          [x - (commonW / 8) * 3, y - (-commonH)],
        )
      }

      leg4(x, y) {
        const { commonH, commonW } = this
        this.funLines(
          [x, y],
          [x - commonW / 8, y - (-commonH / 3) * 1],
          [x - (commonW / 8) * 4, y - (-commonH / 4) * 1],
          [x - (commonW / 8) * 4, y - (-commonH / 8) * 3],
        )
      }

      leg5(x, y) {
        const { commonH, commonW } = this
        this.funLines(
          [x, y],
          [x + commonW / 4, y - (-commonH / 4) * 1],
          [x + commonW / 4 - (commonW / 2), y - (-commonH / 4) * 1],
          [x + commonW / 4 - (commonW / 3) * 2, y - (-commonH / 8) * 3],
        )
      }

      leg6(x, y) {
        const { commonH, commonW } = this
        this.funLines(
          [x, y],
          [x + (commonW / 16) * 6, y - (-commonH / 8) * 1],
          [x, y - (-commonH / 2) * 1],
          [x + commonW / 8, y - (-commonH / 8) * 5],
        )
      }

      leg7(x, y) {
        const { commonH, commonW } = this
        this.funLines(
          [x, y],
          [x + (commonW / 8) * 3, y - (-commonH / 3)],
          [x + (commonW / 8) * 3, y - (-commonH)],
          [x + (commonW / 8) * 3 + commonW / 8, y - (-commonH)],
        )
      }
    }
    new CanvasA()
  </script>
</body>

</html>